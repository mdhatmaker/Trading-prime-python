import sys, os
import numpy as np
import pandas as pd
from statsmodels.tsa.vector_ar import var_model
import statsmodels.tsa.stattools as sm_tools
import statsmodels.tsa.api as smt
import statsmodels
import datetime
import matplotlib.pyplot as plt
from numpy.fft import rfft, irfft

#-----------------------------------------------------------------------------------------------------------------------
from f_folders import *
from f_date import *
from f_plot import *
from f_stats import *
from f_dataframe import *
from f_file import *

pd.set_option('display.width', 160)

fcout = None    # for use with cout function (as file)
#-----------------------------------------------------------------------------------------------------------------------

# Given a time series (pandas series)
# Monitor the progress of stationarizing the given time series with text and PNG plots
# Includes the following:
# - rolling mean and standard deviation of ts with <X-month/day/hour/minute> window
# - ACF
# - PACF
# - QQ Plot
# - histogram
# - computed Augmented-Dickey Fuller Test
# Return results of Augmented-Dickey Fuller test
def ts_diagnostics(y, lags=None, title='', plot_filename=''):
    if not isinstance(y, pd.Series):
        y = pd.Series(y)

    # weekly moving averages (5 day window because of workdays)
    rolling_mean = pd.rolling_mean(y, window=5)     # changed this from window=12
    rolling_std = pd.rolling_std(y, window=5)       # changed this from window=12

    fig = plt.figure(figsize=(14, 12))
    layout = (3, 2)
    ts_ax = plt.subplot2grid(layout, (0, 0), colspan=2)
    acf_ax = plt.subplot2grid(layout, (1, 0))
    pacf_ax = plt.subplot2grid(layout, (1, 1))
    qq_ax = plt.subplot2grid(layout, (2, 0))
    hist_ax = plt.subplot2grid(layout, (2, 1))

    # time series plot
    y.plot(ax=ts_ax)
    rolling_mean.plot(ax=ts_ax, color='crimson');
    rolling_std.plot(ax=ts_ax, color='darkslateblue');
    plt.legend(loc='best')
    ts_ax.set_title(title, fontsize=24);

    # acf and pacf
    smt.graphics.plot_acf(y, lags=lags, ax=acf_ax, alpha=0.5)
    smt.graphics.plot_pacf(y, lags=lags, ax=pacf_ax, alpha=0.5)

    # qq plot
    sm.qqplot(y, line='s', ax=qq_ax)
    qq_ax.set_title('QQ Plot')

    # hist plot
    y.plot(ax=hist_ax, kind='hist', bins=25);
    hist_ax.set_title('Histogram');
    plt.tight_layout();
    filename = join(misc_folder, '{}.png'.format(plot_filename))
    plt.savefig(filename)
    #plt.show()
    plt.show(block=False)

    # perform Augmented Dickey Fuller test
    dftest = test_for_stationarity(y)
    return dftest

# Return a string containing useful notes for examining plots generated by ts_diagnostics
def ts_diagnostics_plot_notes():
    notes = """
    NOTES ABOUT ts_diagnostics PLOTS:
    - Process is not stationary if the dark blue line (time dependent variance) has noticeable slope
    - If mean (red line) appears flat (no slope) at zero, then mean is likely "mean stationary"
    - Look for strong serial correlation in the Autocorrelation plot
    - Check that errors appear to be normally distributed in Histogram plot
    - If log_diff is used, the plotted series can be interpreted as percentages changes ("returns")
    - If there are spikes in the ACF and PACF plots which lie outside the insignifcant zone,
      it can be concluded that the residuals are still not random. This implies that there is
      an information pattern left in the residuals which can be extracted by autoregressive
      and moving average models.
    - When looking at the PACF and ACF plots, a significant spike in the residuals at a
      specific lag (lag 12 for monthly data, for example) can be detected. This indicates
      the seasonal component has not been extracted from the series completely.
    """
    return notes

# Perform Augmented Dickey Fuller test for stationarity
# Return results of Augmented-Dickey Fuller test
def test_for_stationarity(y):
    cout("Results of Augmented Dickey-Fuller test:")
    dftest = smt.adfuller(y, autolag='AIC')
    rounded = map(lambda x: round(x,6), dftest[0:4])
    dfoutput = pd.Series(rounded, index=['test statistic', 'p-value', '# of lags', '# of observations'])
    for key,value in dftest[4].items():
        dfoutput['Critical Value ({})'.format(key)] = round(value, 6)
    cout(dfoutput)
    b, desc = is_stationary(dftest)
    b = "TRUE " if b else "false"
    cout("                 Stationary? {0}   '{1}'".format(b, desc))
    return dftest

# Given the results of an Augmented-Dickey Fuller Test
# Return a bool indicating if series is stationary AND a description (string) if it is not
def is_stationary(dftest):
    test_statistic = dftest[0]
    pvalue = dftest[1]
    nlags = dftest[2]
    nobs = dftest[3]
    critical_values = dftest[4]
    # critical_values['1%'], critical_values['5%'], critical_values['10%']
    stationary = True
    description = ""
    if test_statistic > critical_values['5%'] and pvalue > 0.05:
        description = "moving average is not constant over time"
        stationary = False
    return stationary,description

# Stationarity analysis for the original, unmodified time series
# Return results of Augmented-Dickey Fuller test
def unmodified_stationary(y, lags=40, title='Unmodified Stationary (original series)', id=''):
    cout(title)
    # compute time series diagnostics
    dftest = ts_diagnostics(y, lags=lags, title=title, plot_filename=id+'_adf_original')
    return dftest

# A stochastic process is trend stationary if an underlying trend (function solely
# of time) can be removed, leaving a stationary process.
# With first order differencing we can make a time series trend stationary.
# If more than one differencing step is required we call the process difference stationary.
# Return results of Augmented-Dickey Fuller test
def trend_stationary(y, lags=40, title='Trend Stationary (diff)', id=''):
    cout(title)
    # difference time series
    y_diff = np.diff(y)
    # compute time series diagnostics
    dftest = ts_diagnostics(y_diff, lags=lags, title=title, plot_filename=id+'_adf_diff')
    return dftest

# The log transformation is used to make a time series "variance stationary"
# (stabilizing the variance for the complete time series)
# Note: the series will not be stationary on the mean since the original data and
# not the differenced data is used here
# y'_t = log(y_t)
# Return results of Augmented-Dickey Fuller test
def variance_stationary(y, lags=40, title='Variance Stationary (log)', id=''):
    cout(title)
    # log transform time series
    y_log = np.log(y)
    # compute time series diagnostics
    dftest = ts_diagnostics(y_log, lags=lags, title=title, plot_filename=id+'_adf_log')
    return dftest

# Log transformed first order difference
# y'_t = log(y_t) - log(y_{t-1})
# Return results of Augmented-Dickey Fuller test
def log_diff1_stationary(y, lags=40, title='Log Transformed 1st-Order Diff (log diff1)', id=''):
    cout(title)
    # log difference time series
    #y_log_diff = np.log(y).diff().dropna()
    y_log_diff = np.diff(np.log(y))     #.dropna()
    # compute time series diagnostics
    dftest = ts_diagnostics(y_log_diff, lags=lags, title=title, plot_filename=id+'_adf_log_diff')
    return dftest

# Log transformed second order difference
# y'_t = log(y_t) - log(y_{t-1})
# Return results of Augmented-Dickey Fuller test
def log_diff2_stationary(y, lags=40, title='Log Transformed 2nd-Order Diff (log diff2)', id=''):
    cout(title)
    # log difference time series
    #y_log_diff2 = np.log(y).diff().diff(12).dropna()
    y_log_diff2 = np.diff(np.diff(np.log(y)))   #.dropna()
    # compute time series diagnostics
    dftest = ts_diagnostics(y_log_diff2, lags=lags, title=title, plot_filename=id+'_adf_log_diff2')
    return dftest

# Given a time series (numpy array) AND series description
# (optional) width specifies number of separator chars to use in output (default is 80)
# Run the entire suite of stationarity tests on the series
# Output to MISC data folder PNG files containing plots for each time series diagnostic
# Output to MISC data folder a TXT file containing the time series diagnostic output
def run_stationarity_tests(y, series_description, id='', width=80):
    global fcout
    if id != '':
        output_filename = join(misc_folder, id+"_stationarity_analysis.txt")
        fcout = open(output_filename, 'w')
        print("[OUTPUT TO FILE: '{0}']".format(output_filename))
    cout("\n{0}\n{1}\n{2}".format('=' * width, '=== ' + series_description, '=' * width))
    unmodified_stationary(y, id=id)            # unmodified series
    cout('-' * width)
    trend_stationary(y, id=id)                 # diff
    cout('-' * width)
    variance_stationary(y, id=id)              # log
    cout('-' * width)
    log_diff1_stationary(y, id=id)             # diff(log)
    cout('-' * width)
    log_diff2_stationary(y, id=id)             # diff(diff(log))
    if fcout is not None:
        fcout.close()
    return

# Given a DF_DATA filename, dataframe column name, series description and id
# Run the full suite of stationarity tests
def stationarity_analysis(filename, column, series_description, id):
    # Read (into DataFrame) coinmetrics, daily historical data
    df_xxx = pd.read_csv(dpath(filename), index_col='DateTime')
    dfx = df_xxx[[column]]
    y = dfx.iloc[:, 0].values  # values (prices) of time series
    run_stationarity_tests(y, series_description, id=id)
    return

# Given list of (lowercase) coinmetrics cryptocurrency symbols ('btc', 'eth', etc.)
# Run stationarity tests on each symbol in the list
def coinmetrics_stationarity_analysis(symbols):
    for symbol in symbols:
        filename = "coinmetrics.{0}.daily.DF.csv".format(symbol)
        column = 'PriceUSD'
        series_description = "{0} daily (coinmetrics)".format(symbol.upper())
        id = "{0}_daily".format(symbol.upper())
        stationarity_analysis(filename, column, series_description, id)
    return

#----------------------------------------------------------------------------------------------------
# Given a filename
# Return the full pathname to this file within the DF_DATA folder
def dpath(filename):
    return os.path.join(df_folder, filename)

# Replacement for print function that (optionally) also writes to <fcout> file
def cout(text):
    if not isinstance(text, str): text = str(text)
    print(text)
    if fcout is not None:
        fcout.write(text + '\n')     # also output to file
    return

########################################################################################################################

coinmetrics_stationarity_analysis(coinmetrics_symbols)

